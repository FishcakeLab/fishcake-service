package chain_info

import (
	"context"
	"math/big"
	"sort"
	"strconv"
	"strings"
	"sync"

	"github.com/ethereum/go-ethereum/log"
	"github.com/gin-gonic/gin"

	"github.com/FishcakeLab/fishcake-service/common/api_result"
	"github.com/FishcakeLab/fishcake-service/common/enum"
	"github.com/FishcakeLab/fishcake-service/rpc/account"
	"github.com/FishcakeLab/fishcake-service/service"
)

type SignReturnValue struct {
	Nonce                string `json:"nonce"`
	NativeTokenGasLimit  string `json:"native_token_gas_limit"`
	Erc20TokenGasLimit   string `json:"erc20_token_gas_limit"`
	MaxFeePerGas         string `json:"max_fee_per_gas"`
	MaxPriorityFeePerGas string `json:"max_priority_fee_per_gas"`
	GasPrice             string `json:"gas_price"`
	GasEstimate          string `json:"gas_estimate,omitempty"` // 基于实际交易的 gas 预估
}

type BalanceResultValue struct {
	PolBalance  string `json:"pol_balance"`
	UsdtBalance string `json:"usdt_balance"`
	FccBalance  string `json:"fcc_balance"`
}

type TransactionInfo struct {
	TxHash string `json:"tx_hash"`
	RawTx  string `json:"raw_tx"`
}

func ChainInfoApi(rg *gin.Engine) {
	r := rg.Group("/v1/chain_info")
	r.GET("balance", balance)
	r.GET("balance_sync", balanceSync)
	r.GET("sign_info", signInfo)
	r.GET("send_tx", sentRawTransaction)
	r.GET("transactions", transactions)
	r.POST("submit_tx", submitTx)
	r.GET("txn_status", TxnStatus)
}

func balanceSync(c *gin.Context) {
	address := c.Query("address")
	if address == "" {
		api_result.NewApiResult(c).Error(enum.ParamErr.Code, enum.ParamErr.Msg)
		return
	}

	type balResult struct {
		balance string
		errCode int
		errMsg  string
	}

	var (
		wg      sync.WaitGroup
		resPol  balResult
		resUsdt balResult
		resFcc  balResult
	)
	wg.Add(3)

	// Polygon 主币余额
	go func() {
		defer wg.Done()
		balanceStr, err := service.BaseService.DappLinkService.GetPolBalanceByAddress(address)
		if err != nil {
			resPol.errCode = 500
			resPol.errMsg = err.Error()
			return
		}
		resPol.balance = balanceStr
	}()

	// USDT 余额
	go func() {
		defer wg.Done()
		balanceStr, err := service.BaseService.DappLinkService.GetErc20BalanceByAddress(service.BaseService.RewardService.UsdtAddress(), address)
		if err != nil {
			resUsdt.errCode = 500
			resUsdt.errMsg = err.Error()
			return
		}
		resUsdt.balance = balanceStr
	}()

	// FCC 余额
	go func() {
		defer wg.Done()
		responseFcc, err := service.BaseService.DappLinkService.GetErc20BalanceByAddress(service.BaseService.RewardService.FccAddress(), address)
		if err != nil {
			resFcc.errCode = 500
			resFcc.errMsg = err.Error()
			return
		}
		resFcc.balance = responseFcc
	}()

	wg.Wait()

	// 任意一个失败就直接返回
	if resPol.errCode != 0 {
		api_result.NewApiResult(c).Error(strconv.Itoa(resPol.errCode), resPol.errMsg)
		return
	}
	if resUsdt.errCode != 0 {
		api_result.NewApiResult(c).Error(strconv.Itoa(resUsdt.errCode), resUsdt.errMsg)
		return
	}
	if resFcc.errCode != 0 {
		api_result.NewApiResult(c).Error(strconv.Itoa(resFcc.errCode), resFcc.errMsg)
		return
	}

	balanceRet := BalanceResultValue{
		PolBalance:  resPol.balance,
		UsdtBalance: resUsdt.balance,
		FccBalance:  resFcc.balance,
	}
	api_result.NewApiResult(c).Success(balanceRet)
}

func balance(c *gin.Context) {
	address := c.Query("address")

	if address == "" {
		api_result.NewApiResult(c).Error(enum.ParamErr.Code, enum.ParamErr.Msg)
	}
	reqFcc := &account.AccountRequest{
		Chain:           "Polygon",
		Network:         "mainnet",
		Address:         address,
		ContractAddress: service.BaseService.RewardService.FccAddress(),
	}
	responseFcc, _ := service.BaseService.RpcService.GetAccount(context.Background(), reqFcc)
	if responseFcc.Code == account.ReturnCode_ERROR {
		api_result.NewApiResult(c).Error(enum.GrpcErr.Code, responseFcc.Msg)
		return
	}

	reqPol := &account.AccountRequest{
		Chain:           "Polygon",
		Network:         "mainnet",
		Address:         address,
		ContractAddress: "0x00",
	}
	responsePol, _ := service.BaseService.RpcService.GetAccount(context.Background(), reqPol)
	if responsePol.Code == account.ReturnCode_ERROR {
		api_result.NewApiResult(c).Error(enum.GrpcErr.Code, responsePol.Msg)
		return
	}

	reqUsdt := &account.AccountRequest{
		Chain:           "Polygon",
		Network:         "mainnet",
		Address:         address,
		ContractAddress: service.BaseService.RewardService.UsdtAddress(),
	}
	responseUsdt, _ := service.BaseService.RpcService.GetAccount(context.Background(), reqUsdt)
	if responseUsdt.Code == account.ReturnCode_ERROR {
		api_result.NewApiResult(c).Error(enum.GrpcErr.Code, responseUsdt.Msg)
		return
	}

	balanceRet := BalanceResultValue{
		PolBalance:  responsePol.Balance,
		UsdtBalance: responseUsdt.Balance,
		FccBalance:  responseFcc.Balance,
	}
	api_result.NewApiResult(c).Success(balanceRet)
	return
}

func signInfo(c *gin.Context) {
	address := c.Query("address")
	if address == "" {
		api_result.NewApiResult(c).Error("400", "missing address")
		return
	}

	// 可选参数：用于 gas 预估
	to := c.Query("to")       // 目标地址
	data := c.Query("data")   // 交易 data (hex 格式,如 0x...)
	value := c.Query("value") // 转账金额 (hex 格式,如 0x0)

	// 检查服务是否正确初始化 - 防止 nil pointer panic
	if service.BaseService == nil {
		log.Error("BaseService is nil - service initialization failed")
		api_result.NewApiResult(c).Error("500", "service not initialized, please check database and RPC connection")
		return
	}
	if service.BaseService.Client == nil {
		log.Error("RPC Client is nil - RPC initialization failed")
		api_result.NewApiResult(c).Error("500", "RPC client not initialized, please check polygon_rpc configuration")
		return
	}

	// 1) 获取 nonce - 临时测试版本:直接用 RPC,不依赖数据库
	// TODO: 测试完成后恢复为使用 RpcService
	var nonceHex string
	err := service.BaseService.Client.CallContext(
		context.Background(),
		&nonceHex,
		"eth_getTransactionCount",
		address,
		"pending",
	)
	if err != nil {
		log.Error("get nonce failed", "error", err, "address", address)
		api_result.NewApiResult(c).Error("500", "failed to get nonce: "+err.Error())
		return
	}

	// 定义 parseHexBig 辅助函数
	parseHexBig := func(hexStr string) (*big.Int, bool) {
		s := strings.TrimPrefix(hexStr, "0x")
		if s == "" {
			return nil, false
		}
		v, ok := new(big.Int).SetString(s, 16)
		return v, ok
	}

	// 将 hex nonce 转换为十进制字符串
	nonceBig, ok := parseHexBig(nonceHex)
	if !ok {
		api_result.NewApiResult(c).Error("500", "invalid nonce format")
		return
	}
	nonce := nonceBig.String()

	// 2) feeHistory：增加 blockCount 到 30，percentiles 用更多点，更稳
	const blockCount = 30
	percentiles := []int{10, 25, 50, 75, 90} // 增加 10/90，更好捕捉市场

	var feeHist struct {
		OldestBlock   string     `json:"oldestBlock"`
		BaseFeePerGas []string   `json:"baseFeePerGas"`
		GasUsedRatio  []float64  `json:"gasUsedRatio"`
		Reward        [][]string `json:"reward"`
	}

	err = service.BaseService.Client.CallContext(
		context.Background(),
		&feeHist,
		"eth_feeHistory",
		blockCount,
		"latest",
		percentiles,
	)
	if err != nil {
		api_result.NewApiResult(c).Error(enum.GrpcErr.Code, err.Error())
		return
	}

	// 3) baseFee：取最新
	if len(feeHist.BaseFeePerGas) == 0 {
		api_result.NewApiResult(c).Error(enum.GrpcErr.Code, "invalid baseFee data")
		return
	}
	latestBaseFeeHex := feeHist.BaseFeePerGas[len(feeHist.BaseFeePerGas)-1]
	baseFee, ok := parseHexBig(latestBaseFeeHex)
	if !ok || baseFee.Sign() <= 0 {
		api_result.NewApiResult(c).Error(enum.GrpcErr.Code, "invalid baseFee hex")
		return
	}

	// 4) tip 计算：用 75th 或 90th percentile 的中位数，更稳
	// 优先用 90th（更快打包），fallback 75th → 50th
	getMedian := func(vals []*big.Int) *big.Int {
		if len(vals) == 0 {
			return nil
		}
		sort.Slice(vals, func(i, j int) bool { return vals[i].Cmp(vals[j]) < 0 })
		return new(big.Int).Set(vals[len(vals)/2])
	}

	var tipCandidates []*big.Int
	for _, r := range feeHist.Reward {
		if len(r) < 5 { // 需要至少 90th (index 4)
			continue
		}
		// 优先取 90th percentile (index 4)
		v90, ok90 := parseHexBig(r[4])
		if ok90 && v90.Sign() > 0 {
			tipCandidates = append(tipCandidates, v90)
			continue
		}
		// fallback 75th (index 3)
		v75, ok75 := parseHexBig(r[3])
		if ok75 && v75.Sign() > 0 {
			tipCandidates = append(tipCandidates, v75)
		}
	}

	gwei := big.NewInt(1_000_000_000)
	tip := new(big.Int).Mul(big.NewInt(30), gwei) // 强制 minimum 30 Gwei (Polygon 官方要求)

	if len(tipCandidates) > 0 {
		medianTip := getMedian(tipCandidates)
		if medianTip != nil && medianTip.Cmp(tip) > 0 {
			tip = medianTip
		}
	}

	// 可选：如果想更激进，tip 上限可放宽到 150 Gwei（当前市场 fast ~120 Gwei）
	maxTip := new(big.Int).Mul(big.NewInt(150), gwei)
	if tip.Cmp(maxTip) > 0 {
		tip = maxTip
	}

	// 5) maxFee：baseFee * 2 + tip，不硬 cap 200 Gwei，而是 cap 在更高值（当前 base fee 高时需要）
	// 或者干脆不 cap，让 relay 自己处理
	maxFee := new(big.Int).Mul(baseFee, big.NewInt(2))
	maxFee.Add(maxFee, tip)

	// 推荐 cap：800–1000 Gwei（覆盖当前 ~500–600 base fee + tip）
	maxFeeCap := new(big.Int).Mul(big.NewInt(1000), gwei)
	if maxFee.Cmp(maxFeeCap) > 0 {
		maxFee = maxFeeCap
	}

	// 6) legacy gasPrice：base + tip，cap 1000 Gwei
	legacyGasPrice := new(big.Int).Add(baseFee, tip)
	if legacyGasPrice.Cmp(maxFeeCap) > 0 {
		legacyGasPrice = maxFeeCap
	}

	// 7) Gas 预估：如果提供了 to 地址，则调用 eth_estimateGas
	var gasEstimate string
	if to != "" {
		// 构造 estimateGas 请求参数
		estimateParams := map[string]interface{}{
			"from": address,
			"to":   to,
		}

		// data 是可选的，如果提供了就加上
		if data != "" {
			estimateParams["data"] = data
		}

		// value 是可选的，默认为 0x0
		if value != "" {
			estimateParams["value"] = value
		} else {
			estimateParams["value"] = "0x0"
		}

		var estimateResult string
		err := service.BaseService.Client.CallContext(
			context.Background(),
			&estimateResult,
			"eth_estimateGas",
			estimateParams,
		)

		if err != nil {
			// gas 预估失败不影响其他数据的返回，只是不返回 gasEstimate
			log.Error("eth_estimateGas failed", "error", err, "from", address, "to", to)
		} else {
			// 将 hex 结果转换为十进制字符串
			if estimatedGas, ok := parseHexBig(estimateResult); ok {
				// 建议在预估值基础上增加 20% 的 buffer，避免 out of gas
				buffer := new(big.Int).Div(estimatedGas, big.NewInt(5)) // 20% = 1/5
				estimatedGas.Add(estimatedGas, buffer)
				gasEstimate = estimatedGas.String()
			}
		}
	}

	// 8) gasLimit 建议：approve 实际 45k–65k，设 80k–100k 更合理（避免 over-estimate）
	// 但你当前 100000 还行，可微调到 "80000"

	retValue := SignReturnValue{
		Nonce:                nonce, // 临时测试版本:使用 RPC 获取的 nonce
		NativeTokenGasLimit:  "21000",
		Erc20TokenGasLimit:   "100000",
		MaxFeePerGas:         maxFee.String(),
		MaxPriorityFeePerGas: tip.String(),
		GasPrice:             legacyGasPrice.String(),
		GasEstimate:          gasEstimate, // 如果没有预估则为空字符串
	}

	api_result.NewApiResult(c).Success(retValue)
}

func sentRawTransaction(c *gin.Context) {
	rawTx := c.Query("rawTx")
	req := &account.SendTxRequest{
		Chain:   "Polygon",
		Network: "mainnet",
		RawTx:   rawTx,
	}
	exist := service.BaseService.WalletService.IsExistRawTx(rawTx)
	if exist {
		api_result.NewApiResult(c).Error("400", "raw tx is already exist queue tx")
		return
	}
	response, _ := service.BaseService.RpcService.SendTx(context.Background(), req)
	if response == nil {
		api_result.NewApiResult(c).Error(enum.GrpcErr.Code, "send tx fail, please try again later")
		return
	}
	if response.Code == account.ReturnCode_ERROR {
		api_result.NewApiResult(c).Error(enum.GrpcErr.Code, response.Msg)
		return
	}
	api_result.NewApiResult(c).Success(response.TxHash)
	return
}

func transactions(c *gin.Context) {
	address := c.Query("address")
	contractAddress := c.Query("contractAddress")
	if address == "" || contractAddress == "" {
		api_result.NewApiResult(c).Error(enum.ParamErr.Code, enum.ParamErr.Msg)
	}
	req := &account.TxAddressRequest{
		Chain:   "Polygon",
		Network: "mainnet",
		Address: address,
	}
	response, _ := service.BaseService.RpcService.GetTxByAddress(context.Background(), req)
	if response.Code == account.ReturnCode_ERROR {
		api_result.NewApiResult(c).Success(response)
		return
	}
	api_result.NewApiResult(c).Error(enum.GrpcErr.Code, response.Msg)
}

func submitTx(c *gin.Context) {
	var txInfo TransactionInfo
	if err := c.ShouldBindJSON(&txInfo); err != nil {
		api_result.NewApiResult(c).Error("400", "param parse fail")
		return
	}
	exist := service.BaseService.WalletService.IsExistRawTx(txInfo.RawTx)
	if exist {
		api_result.NewApiResult(c).Error("400", "raw tx is already exist queue tx")
		return
	}
	err := service.BaseService.WalletService.StoreRawTx(txInfo.RawTx, txInfo.TxHash)
	if err != nil {
		api_result.NewApiResult(c).Error("400", "store raw tx to queue tx fail")
		return
	}
	api_result.NewApiResult(c).Success("ok")
}

func TxnStatus(c *gin.Context) {
	txHash := c.Query("hash")
	if txHash == "" {
		api_result.NewApiResult(c).Error(enum.ParamErr.Code, enum.ParamErr.Msg)
	}
	queueTx, err := service.BaseService.WalletService.QueryTxInfoByHash(txHash)
	if err != nil {
		log.Error("query transaction info fail", "err", err)
		api_result.NewApiResult(c).Error("400", "query tx fail")
		return
	}
	api_result.NewApiResult(c).Success(queueTx)

}
